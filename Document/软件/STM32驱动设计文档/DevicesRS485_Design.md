# STM32F10x RS485 设计文档 (DevicesRS485)

| 属性 | 内容 |
| :--- | :--- |
| **模块名称** | DevicesRS485 (RS485 总线驱动模块) |
| **源文件** | `DevicesRS485.c` / `DevicesRS485.h` |
| **硬件依赖** | USART2, MAX485 芯片, GPIO (方向控制) |
| **软件依赖** | DevicesUart, DevicesDelay, DevicesQueue |
| **版本** | v1.0 |
| **最后更新** | 2026-02-04 |

---

## 1. 设计目标 (Design Goals)

实现基于 MAX485 芯片的 RS485 半双工通信驱动：

1. **半双工通信**：软件控制收发方向切换
2. **多机通信**：支持总线上多个设备（主从模式）
3. **长距离传输**：差分信号抗干扰，支持 1200m 传输距离
4. **可靠切换**：正确处理收发模式切换时序，避免数据丢失

---

## 2. RS485 基础原理 (RS485 Fundamentals)

### 2.1 什么是 RS485？

RS485 是一种 **差分信号** 的串行通信标准，使用两根信号线 (A、B) 传输数据。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         RS485 vs RS232 对比                                  │
└─────────────────────────────────────────────────────────────────────────────┘

RS232 (单端信号):
                          
    TX ─────────────────────────────────────────► RX
    GND ────────────────────────────────────────► GND
    
    - 信号参考 GND
    - 容易受干扰
    - 传输距离短 (~15m)
    - 点对点通信


RS485 (差分信号):

    A ──────────────────────────────────────────► A
    B ──────────────────────────────────────────► B
    
    - 信号 = A - B (差值)
    - 抗共模干扰强
    - 传输距离长 (~1200m)
    - 支持多机通信 (最多 32 个节点)
```

### 2.2 差分信号原理

RS485 使用 **A-B 差分电压** 表示逻辑电平：

| 逻辑值 | A 电平 | B 电平 | 差分电压 (A-B) | 说明 |
| :--- | :--- | :--- | :--- | :--- |
| **逻辑 1** | ~3.3V (高) | ~0V (低) | +200mV ~ +6V | A > B |
| **逻辑 0** | ~0V (低) | ~3.3V (高) | -200mV ~ -6V | A < B |
| **空闲态** | 上拉到高 | 下拉到低 | 正电压 | 相当于逻辑 1 |

```
差分信号波形示例（发送 0x55 = 01010101）:

    A 线:  ┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐
           └──┘  └──┘  └──┘  └──┘  └──
           
    B 线:  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──
           ┘  └──┘  └──┘  └──┘  └──┘
           
    A-B:   +  -  +  -  +  -  +  -
    逻辑:   1  0  1  0  1  0  1  0
```

**为什么差分信号抗干扰？**

```
干扰信号同时作用于 A 和 B:

原始信号:     A = 3.3V, B = 0V    →  A - B = +3.3V (逻辑 1)

叠加干扰后:   A = 3.3V + 1V = 4.3V
             B = 0V + 1V = 1V
             
             A - B = 4.3V - 1V = +3.3V (仍然是逻辑 1！)

干扰被抵消了！这就是差分信号的优势。
```

### 2.3 MAX485 芯片引脚功能

```
                    ┌────────────┐
        USART_RX ◄──┤ 1  RO  VCC ├── 8  VCC (3.3V/5V)
                    │            │
 方向控制 (低=接收) ──┤ 2  #RE  B ├── 7  B 线 (差分信号-)
                    │            │
 方向控制 (高=发送) ──┤ 3  DE   A ├── 6  A 线 (差分信号+)
                    │            │
        USART_TX ──►┤ 4  DI GND ├── 5  GND
                    └────────────┘
```

| 引脚 | 名称 | 功能 | 说明 |
| :--- | :--- | :--- | :--- |
| 1 | RO | Receiver Output | 接收器输出，连接 MCU 的 RX |
| 2 | #RE | Receiver Enable | 接收使能，**低电平有效** |
| 3 | DE | Driver Enable | 发送使能，**高电平有效** |
| 4 | DI | Driver Input | 发送器输入，连接 MCU 的 TX |
| 5 | GND | Ground | 电源地 |
| 6 | A | Non-inverting | 差分信号 A 线 (正) |
| 7 | B | Inverting | 差分信号 B 线 (负) |
| 8 | VCC | Power Supply | 电源 (3.3V 或 5V) |

### 2.4 收发模式切换

由于 **#RE 低有效、DE 高有效**，通常将它们连接在一起，用一个 GPIO 控制：

| GPIO 电平 | #RE | DE | 模式 |
| :--- | :--- | :--- | :--- |
| **低 (0)** | 0 (有效) | 0 (无效) | **接收模式** |
| **高 (1)** | 1 (无效) | 1 (有效) | **发送模式** |

```c
#define RS485_BUS_MODE_RECEIVE()    HAL_GPIO_WritePin(RS485_BUS_GPIO_Port, RS485_BUS_Pin, GPIO_PIN_RESET);
#define RS485_BUS_MODE_SEND()       HAL_GPIO_WritePin(RS485_BUS_GPIO_Port, RS485_BUS_Pin, GPIO_PIN_SET);
```

---

## 3. 硬件电路设计 (Hardware Design)

### 3.1 典型电路原理图

```
                          VCC                    VCC
                           │                      │
                          ┌┴┐                    ┌┴┐
                          │ │ R6               │ │ R4
                          │ │ 4.7K              │ │ 4.7K
                          └┬┘                    └┬┘
                           │                      │
                           │      ┌─────────┐    │
    USART_RX ◄─────────────┼──────┤ 1 RO    ├────┘
                           │      │         │
                           ├──────┤ 2 #RE   │
    方向控制 ──────┐        │      │  MAX485 │
    (GPIO/Q1) ────┼────────┼──────┤ 3 DE    │
                  │        │      │         │
    USART_TX ─────┼────────┼──────┤ 4 DI    │
                  │        │      │      VCC├── 8  VCC
                  │        │      │         │
                  │        │      │       B ├── 7 ──┬──┬── RS485_B
                  │        │      │         │      │ ┌┴┐
                  │        │      │       A ├── 6 ─┼─┤ │ R1 120Ω
                  │        │      │         │      │ └┬┘ (终端电阻)
                  │        │      │     GND ├── 5 ─┼──┴── RS485_A
                  │        │      └─────────┘      │
                  │        │                      ┌┴┐
                  │        GND                    │ │ R2 4.7K (B上拉)
                  │                               └┬┘
                  │                                VCC
                  │
                 ┌┴┐
                 │ │ R7 4.7K
                 └┬┘                              ┌┴┐
                  │                               │ │ R3 4.7K (A下拉)
                 ─┴─ Q1 (NPN三极管，可选)          └┬┘
                  │                                GND
                 GND
```

### 3.2 关键电阻的作用

#### 3.2.1 终端电阻 (120Ω) — 消除信号反射

**为什么需要 120Ω 终端电阻？**

RS485 总线传输的是高速电信号。当信号到达总线末端时，如果没有匹配的负载，会产生 **信号反射**，就像声波遇到墙壁会产生回声一样。

```
无终端电阻时的信号反射:

发送端                                                      接收端(开路)
  │                                                            │
  │ ─────────────────────────────────────────────────────────► │
  │                              原始信号                       │
  │                                                            │
  │ ◄───────────────────────────────────────────────────────── │
  │                              反射信号                       │
  │                                                            │
  
信号波形叠加后:
  
原始波形:   ┌────────┐
            │        │
         ───┘        └───
            
反射叠加:   ┌────┬───┐     ← 信号产生震荡、过冲
            │    │   │
         ───┘    └───└───
         
         可能导致误判！
```

**120Ω 的来源**：RS485 标准规定差分阻抗约为 120Ω，终端电阻需要与传输线特性阻抗匹配。

```
有终端电阻时:

发送端                                                      接收端
  │                                                     ┌───┐  │
  │ ─────────────────────────────────────────────────── │120│──│
  │                              原始信号               │ Ω │  │
  │                                                     └───┘  │
  │                                                            │
  │                         反射能量被 120Ω 吸收，无反射        │
  
信号波形:
  
            ┌────────┐     ← 干净的方波，无震荡
            │        │
         ───┘        └───
```

**终端电阻的位置**：
- 只在总线 **两端** 的设备上安装 120Ω 电阻
- 中间节点不需要安装
- 如果总线很短（< 10m）或波特率很低（< 9600），可以不装

```
正确的终端电阻布局:

  节点1       节点2       节点3       节点4
   │           │           │           │
 ┌─┴─┐       ┌─┴─┐       ┌─┴─┐       ┌─┴─┐
 │MCU│       │MCU│       │MCU│       │MCU│
 └─┬─┘       └─┬─┘       └─┬─┘       └─┬─┘
   │           │           │           │
 [120Ω]────────┴───────────┴────────[120Ω]
   ├───────────────────────────────────┤
                 RS485 总线
                 
   ↑                                   ↑
  端点1                               端点2
 (需要终端电阻)                      (需要终端电阻)
```

#### 3.2.2 偏置电阻 (A 下拉 + B 上拉) — 确保空闲态稳定

当总线空闲（所有设备都处于接收模式）时，A、B 线处于高阻态，电平不确定，容易受干扰产生误触发。

**解决方案**：用偏置电阻将空闲态稳定在 **逻辑 1** (A > B)：

```
偏置电阻配置:

    VCC
     │
    ┌┴┐
    │ │ R2 4.7K (B 上拉)
    └┬┘
     │
     B ────────────────────── 总线
     │
     A ────────────────────── 总线
     │
    ┌┴┐
    │ │ R3 4.7K (A 下拉)
    └┬┘
     │
    GND
    
空闲时: B 被拉高, A 被拉低 → A-B < 0 → 接收器输出高电平(空闲)
```

---

## 4. 软件设计重点 (Software Design Key Points)

### 4.1 为什么要在模式切换后增加延时？

这是 RS485 驱动设计中 **最关键** 的一点！

```c
int8_t cRS485xSendDatas(uint32_t uiChannel, void *pvBuff, int32_t iLength)
{
    /* 设置为发送模式 */
    RS485_BUS_MODE_SEND();

    /* ⭐ RS485协议推荐在设置为发送模式之后，增加一个bit的延时 */
    vDelayUs(1000000.0f / 9600.0f);  // 约 104μs (9600波特率下 1 bit 的时间)

    /* 发送数据 */
    vUartDMASendDatas(uiChannel, pvBuff, iLength);

    /* ⭐ RS485协议推荐在设置为接收模式之前，增加一个bit的延时 */
    vDelayUs(1000000.0f / 9600.0f);

    /* 设置为接收模式 */
    RS485_BUS_MODE_RECEIVE();
}
```

#### 4.1.1 问题：模式切换过程中的竞争冒险

MAX485 芯片在 DE/RE 信号切换时，内部有一个 **过渡过程**：

```
时序图 — 不加延时的问题:

GPIO (DE/#RE):  ──────┐                    ┌──────
                      └────────────────────┘
                      ↑                    ↑
                 切换到发送             切换到接收
                      
MAX485 内部状态:  接收 → [过渡] → 发送 → ... → [过渡] → 接收
                        ~1μs                     ~1μs
                        
UART TX:         ─────────┐     ┌───────────────────
                          └─────┘  起始位
                          
问题1: 如果 GPIO 刚切换，UART 立即发送，
       此时 MAX485 还没完全进入发送模式 → 起始位可能丢失！

问题2: 如果数据刚发完，立即切换到接收模式，
       此时最后一个字节还在 MAX485 发送寄存器中 → 尾部数据丢失！
```

#### 4.1.2 解决方案：在模式切换后增加 1 bit 延时

```
正确的时序:

GPIO (DE/#RE):  ──────┐                              ┌──────
                      └──────────────────────────────┘
                      ↑    ↑                    ↑    ↑
                 切换发送 延时1bit          延时1bit 切换接收
                      
延时:                 │←───►│                  │←───►│
                      ~104μs                   ~104μs
                      (9600波特率)              
                        
UART TX:         ───────────┐     ┌─────────────────────
                            └─────┘
                            
MAX485 内部:     接收 → [过渡] → 稳定发送 → ... → [过渡] → 稳定接收
                               ↑               ↑
                          数据开始发送    数据完全发出
```

**延时时间计算**：

```
1 bit 时间 = 1 / 波特率

波特率      1 bit 时间
────────────────────────
9600        104.2 μs
19200       52.1 μs
38400       26.0 μs
115200      8.7 μs

代码实现:
vDelayUs(1000000.0f / 9600.0f);  // 1000000μs / 9600 ≈ 104μs
```

#### 4.1.3 不加延时的后果

| 问题 | 现象 | 原因 |
| :--- | :--- | :--- |
| 发送第一个字节丢失 | 接收端收到数据少一个字节 | 切换到发送模式后立即发送，MAX485 还在过渡态 |
| 最后一个字节丢失 | 接收端收到数据少一个字节 | 数据还没完全发出就切换到接收模式 |
| 帧头/帧尾错误 | CRC 校验失败 | 起始位或停止位被截断 |
| 偶发通信失败 | 时好时坏 | 时序临界状态，受温度/电压影响 |

### 4.2 为什么不使用自收发电路？

从原理图可以看到，有些设计用三极管 Q1 实现 "自收发" 功能：TX 信号自动控制收发方向切换。

```
自收发电路原理:

                      VCC
                       │
                      ┌┴┐ R6
                      │ │ 4.7K (DE/#RE 上拉)
                      └┬┘
                       │
    USART_TX ────┬─────┼───────────────────► DI (MAX485)
                 │     │
                ┌┴┐ R7 │
                │ │4.7K│
                └┬┘    │
                 │     ▼
               ──┴── Q1 (NPN) ──────────────► DE/#RE
                 │
                GND
                 
当 TX = 高 (空闲/发1): Q1 导通 → DE/#RE 被拉低 → 接收模式
当 TX = 低 (起始位/发0): Q1 截止 → DE/#RE 被上拉到高 → 发送模式
```

#### 4.2.1 自收发电路的致命问题：发 0 驱动力强，发 1 驱动力弱

**问题本质**：用三极管实现的自收发电路，在发送 **逻辑 0** 和 **逻辑 1** 时，MAX485 的工作状态不同！

```
分析发送 0x55 (01010101) 时的情况:

                TX 电平    Q1 状态    DE/#RE    MAX485 模式
                ─────────────────────────────────────────────
发送 bit0 (1):    高        导通       低        接收模式 ✗ (驱动器关闭)
发送 bit1 (0):    低        截止       高        发送模式 ✓ (驱动器工作)
发送 bit2 (1):    高        导通       低        接收模式 ✗ (驱动器关闭)
发送 bit3 (0):    低        截止       高        发送模式 ✓ (驱动器工作)
...

关键问题: 
- 发送 0 时：MAX485 驱动器正常工作，驱动力强
- 发送 1 时：MAX485 进入接收模式，驱动器关闭，A/B 线变成高阻态！
```

#### 4.2.2 分压公式分析 — 为什么发 1 时信号会被严重分压

当发送逻辑 1（TX = 高）时，Q1 导通，DE/#RE 被拉低，**MAX485 驱动器关闭**。

此时 A/B 线变成高阻态，信号只能靠偏置电阻维持。但是，**120Ω 终端电阻会严重分压**！

```
发送 1 时的等效电路:

    VCC ──────────────────────────────────────┐
           │                                  │
          ┌┴┐ R2                              │
          │ │ 4.7K (B上拉)                    │
          └┬┘                                 │
           │                                  │
           B ◄────────────────────────────────┤
           │                                  │
          ┌┴┐ R1                              │
          │ │ 120Ω (终端电阻)                 │
          └┬┘                                 │
           │                                  │
           A ◄────────────────────────────────┤
           │                                  │
          ┌┴┐ R3                              │
          │ │ 4.7K (A下拉)                    │
          └┬┘                                 │
           │                                  │
    GND ──────────────────────────────────────┘


简化等效电路 (串联分压):

    VCC
     │
    ┌┴┐ R2 = 4.7K
    └┬┘
     │
     B ────► VB = ?
     │
    ┌┴┐ R1 = 120Ω
    └┬┘
     │
     A ────► VA = ?
     │
    ┌┴┐ R3 = 4.7K
    └┬┘
     │
    GND


分压计算:

总电阻 = R2 + R1 + R3 = 4700 + 120 + 4700 = 9520Ω

VB = VCC × (R1 + R3) / (R2 + R1 + R3)
   = 3.3V × (120 + 4700) / 9520
   = 3.3V × 4820 / 9520
   = 3.3V × 0.506
   ≈ 1.67V

VA = VCC × R3 / (R2 + R1 + R3)
   = 3.3V × 4700 / 9520
   ≈ 1.63V

差分电压 A-B = VA - VB = 1.63V - 1.67V = -0.04V ≈ 0V !!!
```

**严重问题**：RS485 接收器需要至少 **±200mV** 的差分电压才能正确判断，但计算结果只有约 **40mV**，远远不够！

#### 4.2.3 对比：发 0 和发 1 的信号质量差异

| 状态 | MAX485 模式 | A-B 差分电压 | 驱动力 |
| :--- | :--- | :--- | :--- |
| **发送 0** | 发送模式 (驱动器工作) | 约 **-2V ~ -3V** | 强 ✓ |
| **发送 1** | 接收模式 (驱动器关闭) | 约 **-0.04V** | 极弱 ✗ |

```
信号波形对比:

正常驱动 (GPIO 控制方向，驱动器始终工作):

A-B 电压:   
    +2V ──┐        ┌────────┐        ┌──
          │        │        │        │
     0V   │        │        │        │
          │        │        │        │
    -2V ──└────────┘        └────────┘
          
          发1      发0      发1      发0
          
          ← 差分电压 ±2V，边沿陡峭，信号清晰


自收发电路 (发1时驱动器关闭):

A-B 电压:
    +2V 
          
     0V ──────┐    ┌────────┐    ┌────── ← 发1时差分电压≈0
              │    │        │    │
    -2V       └────┘        └────┘
          
          发1  发0    发1    发0   发1
          
          ← 发1时几乎没有差分电压！
          ← 接收器很可能误判为0或产生抖动
```

#### 4.2.4 为什么 120Ω 终端电阻会"吃掉"信号？

关键在于阻抗不匹配：

```
偏置电阻: 4.7K + 4.7K = 9.4K (总源阻抗)
终端电阻: 120Ω (负载阻抗)

电流主要流过 120Ω (因为它阻值最小)，
4.7K 上的压降反而很小，
导致 A、B 两点电压几乎相等！

这就像用一根很细的水管 (4.7K) 给一个大水池 (120Ω) 供水，
水池里的水位几乎没有高度差。
```

#### 4.2.5 结论：必须使用 GPIO 显式控制方向

| 方案 | 发0信号 | 发1信号 | 可靠性 | 推荐度 |
| :--- | :--- | :--- | :--- | :--- |
| **GPIO 显式控制** | 强 | 强 | 高 | ⭐⭐⭐⭐⭐ |
| 自收发电路 (三极管) | 强 | **极弱** (被120Ω分压) | 低 | ⭐ |
| 自收发芯片 (如 MAX13487) | 强 | 强 | 高 | ⭐⭐⭐⭐ |

> **经验总结**：自收发电路看似节省一个 GPIO，但会导致发送 1 时信号被终端电阻严重分压，在长距离或多节点场景下极易出现通信错误。**强烈建议使用 GPIO 显式控制收发方向**。

---

## 5. 软件实现 (Software Implementation)

### 5.1 初始化

```c
void vRS485BusInit(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    __HAL_RCC_GPIOD_CLK_ENABLE();

    /* 配置方向控制引脚 */
    GPIO_InitStruct.Pin = RS485_BUS_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(RS485_BUS_GPIO_Port, &GPIO_InitStruct);

    /* 默认为接收模式 */
    RS485_BUS_MODE_RECEIVE();
}
```

### 5.2 发送函数

```c
int8_t cRS485xSendDatas(uint32_t uiChannel, void *pvBuff, int32_t iLength)
{
    if(uiChannel == (uint32_t)UART_BUS)
    {
        /* 1. 切换到发送模式 */
        RS485_BUS_MODE_SEND();

        /* 2. 等待 MAX485 稳定进入发送模式 (1 bit 延时) */
        vDelayUs(1000000.0f / 9600.0f);

        /* 3. 发送数据 (DMA 方式) */
        vUartDMASendDatas(uiChannel, pvBuff, iLength);
        // 注意: vUartDMASendDatas 内部已等待发送完成 (DMA + TC 标志)

        /* 4. 等待最后一个字节完全发出 (1 bit 延时) */
        vDelayUs(1000000.0f / 9600.0f);

        /* 5. 切换到接收模式 */
        RS485_BUS_MODE_RECEIVE();
    }

    return 0;
}
```

### 5.3 接收函数 (封装 UART 接口)

```c
/* 接收指定长度数据 */
int8_t cRS485xReceiveDatas(uint32_t uiChannel, void *pvBuff, int32_t iLength)
{
    return cUartReceiveDatas(uiChannel, pvBuff, iLength);
}

/* 接收所有可用数据 */
int32_t iRS485xReceiveAllDatas(uint32_t uiChannel, void *pvBuff, int32_t iLengthLimit)
{
    return iUartReceiveAllDatas(uiChannel, pvBuff, iLengthLimit);
}

/* 获取接收缓冲区数据长度 */
int32_t iRS485xReceiveLengthGet(uint32_t uiChannel)
{
    return iUartReceiveLengthGet(uiChannel);
}

/* 清空接收缓冲区 */
int8_t cRS485xReceiveClear(uint32_t uiChannel)
{
    return cUartReceiveClear(uiChannel);
}
```

---

## 6. 总线通信特性 (Bus Communication)

### 6.1 多机通信原理

RS485 是 **总线型** 拓扑，所有设备共享同一对 A/B 线：

```
                       RS485 总线 (A/B 线)
    ════════════════════════════════════════════════════
           │           │           │           │
         ┌─┴─┐       ┌─┴─┐       ┌─┴─┐       ┌─┴─┐
         │主机│       │从机1│     │从机2│     │从机3│
         │ID=0│       │ID=1│      │ID=2│      │ID=3│
         └───┘       └───┘       └───┘       └───┘
```

**关键特性**：
- 同一时刻只能有 **一个设备** 处于发送模式
- 所有处于接收模式的设备都能收到总线上的数据
- 通过 **地址/ID** 区分数据是发给谁的

### 6.2 典型的主从通信协议

```
主机发送请求:

  帧头    从机地址    功能码    数据区    CRC校验
┌──────┬──────────┬────────┬─────────┬─────────┐
│ 0xAA │   0x01   │  0x03  │ ....... │  CRC16  │
└──────┴──────────┴────────┴─────────┴─────────┘
           ↑
       目标从机地址


所有从机都收到这个数据，但只有地址匹配的从机响应:

从机1 (地址=0x01): 地址匹配 → 处理请求 → 发送响应
从机2 (地址=0x02): 地址不匹配 → 忽略
从机3 (地址=0x03): 地址不匹配 → 忽略
```

### 6.3 总线冲突避免

由于是半双工通信，必须避免多个设备同时发送：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           避免总线冲突的策略                                  │
└─────────────────────────────────────────────────────────────────────────────┘

1. 主从模式 (最常用)
   - 从机只有在收到主机请求后才能发送
   - 任何时刻只有一个从机被寻址
   
2. 令牌传递
   - 持有令牌的设备才能发送
   - 发送完毕后将令牌传给下一个设备
   
3. CSMA/CD (带冲突检测)
   - 发送前检测总线是否空闲
   - 检测到冲突后随机延时重发
```

---

## 7. API 总览 (API Reference)

| 函数 | 功能 | 参数 | 返回值 |
| :--- | :--- | :--- | :--- |
| `vRS485BusInit()` | 初始化 RS485 方向控制 GPIO | 无 | 无 |
| `cRS485xSendDatas()` | 发送数据 | 通道, 数据指针, 长度 | 0: 成功 |
| `cRS485xReceiveDatas()` | 接收指定长度数据 | 通道, 数据指针, 长度 | 0: 成功 |
| `iRS485xReceiveAllDatas()` | 接收所有可用数据 | 通道, 数据指针, 最大长度 | 实际长度 |
| `cRS485xReceiveByte()` | 接收单字节 | 通道, 数据指针 | 0: 成功 |
| `iRS485xReceiveLengthGet()` | 获取接收缓冲区长度 | 通道 | 数据长度 |
| `cRS485xReceiveClear()` | 清空接收缓冲区 | 通道 | 0: 成功 |

---

## 8. 使用示例 (Usage Examples)

### 8.1 初始化

```c
#include "DevicesRS485.h"
#include "DevicesUart.h"
#include "DevicesQueue.h"

void SystemInit(void)
{
    enumQueueInit();    // 初始化队列
    vUart2Init();       // 初始化 UART2 (RS485 使用的串口)
    vRS485BusInit();    // 初始化 RS485 方向控制
}
```

### 8.2 主机发送请求

```c
void MasterSendRequest(uint8_t slaveAddr, uint8_t funcCode, uint8_t *data, uint16_t len)
{
    uint8_t txBuff[256];
    uint16_t idx = 0;
    uint16_t crc;
    
    // 构造帧
    txBuff[idx++] = 0xAA;           // 帧头
    txBuff[idx++] = slaveAddr;      // 从机地址
    txBuff[idx++] = funcCode;       // 功能码
    memcpy(&txBuff[idx], data, len);
    idx += len;
    
    // 计算 CRC
    crc = CRC16_Calculate(txBuff, idx);
    txBuff[idx++] = crc & 0xFF;
    txBuff[idx++] = (crc >> 8) & 0xFF;
    
    // 发送
    cRS485xSendDatas(UART_BUS, txBuff, idx);
}
```

### 8.3 从机接收处理

```c
void SlaveProcessTask(void)
{
    uint8_t rxBuff[256];
    int32_t rxLen;
    
    while(1)
    {
        // 检查是否有数据
        rxLen = iRS485xReceiveAllDatas(UART_BUS, rxBuff, sizeof(rxBuff));
        
        if(rxLen > 0)
        {
            // 检查地址是否匹配
            if(rxBuff[1] == MY_SLAVE_ADDR)
            {
                // 处理请求并响应
                ProcessAndRespond(rxBuff, rxLen);
            }
            // 地址不匹配则忽略
        }
        
        vTaskDelay(10);
    }
}
```

---

## 9. 常见问题与调试 (Troubleshooting)

### Q1: 发送第一个字节丢失

**原因**：切换到发送模式后没有延时，MAX485 还在过渡态

**解决**：在 `RS485_BUS_MODE_SEND()` 后增加 1 bit 延时

### Q2: 最后一个字节丢失

**原因**：数据还没完全发出就切换到接收模式

**解决**：
1. 等待 UART TC 标志 (在 `vUartDMASendDatas` 中已实现)
2. 在切换接收模式前再加 1 bit 延时

### Q3: 长距离通信不稳定

**可能原因**：
1. 没有安装终端电阻
2. 没有偏置电阻
3. 波特率过高

**解决**：
1. 在总线两端安装 120Ω 终端电阻
2. 安装 A 下拉 + B 上拉偏置电阻
3. 降低波特率

### Q4: 多节点通信偶发错误

**可能原因**：
1. 总线冲突（多个设备同时发送）
2. 响应超时时间设置不合理

**解决**：
1. 确保严格的主从协议
2. 调整超时时间

---

## 10. 硬件设计检查清单 (Hardware Checklist)

- [ ] MAX485 芯片供电正确 (3.3V 或 5V)
- [ ] DE/#RE 连接正确，方向控制 GPIO 正常
- [ ] DI 连接 MCU TX，RO 连接 MCU RX
- [ ] 总线两端安装 120Ω 终端电阻
- [ ] A 线有下拉电阻，B 线有上拉电阻
- [ ] 所有节点共地
- [ ] 使用双绞线，A/B 线绞在一起

---

## 11. 版本变更记录 (Changelog)

| 版本 | 日期 | 变更内容 |
| :--- | :--- | :--- |
| v1.0 | 2026-02-04 | 初始版本 |

---

**文档结束**
