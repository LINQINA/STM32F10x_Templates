# 主控与上位机通讯设计文档

| 属性     | 内容 |
| :------- | :--- |
| **模块** | 主控 ↔ 上位机 Modbus 通讯架构 |
| **涉及** | TaskMessageSlave / TaskMessageUpdate / TaskMessageControl / DriverModbus / DevicesQueue / DevicesUart |
| **版本** | v1.0 |
| **最后更新** | 2026-02-06 |

---

## 1. 概述

主控与上位机、以及主控与总线上其他从设备（如 BMS、逆变器等）的通讯统一走 **Modbus RTU**，在软件上分为两类路径：

1. **透传（从机）**：上位机发来的帧由主控**逐字节解析**，根据从站地址决定是**本机应答**还是**转发到 BUS 并回传**。
2. **主动请求**：主控**主动**向总线上从机发起读/写请求，**已知应答长度**，按**整包**接收并解析。

协议与总线占用在 **DriverModbus** 中统一处理，通过 **互斥信号量** 保证同一时刻只有一方使用 BUS（或 LOG 口），避免多任务同时发数导致总线冲突。

---

## 2. 通道与队列

### 2.1 通道定义

| 通道       | 宏/硬件     | 用途说明 |
| :--------- | :---------- | :------- |
| **UART_LOG** | USART1 (115200) | 上位机通讯串口（或日志）；在本工程的 TaskMessageSlave 中作为 **回复通道**（cModbusUnpack 的 uiChannel 参数）。 |
| **UART_BUS** | USART2 (RS485)  | Modbus 总线：主动请求（读/写从机）、透传时与从机通信均通过此通道。在本工程中 TaskMessageSlave 从该通道的队列接收上位机数据。 |

> **注意**：本工程 TaskMessageSlave 从 `g_TypeQueueUart1Read`（UART_BUS 队列）取数据，但 `cModbusUnpack` 的 uiChannel 传入 `UART_LOG`，即**接收来源是 UART_BUS，回复通道是 UART_LOG**。这意味着上位机与总线从机可能共享同一条 RS485（UART_BUS），而回复经另一路 UART（UART_LOG）返回；或者在实际硬件中需要根据接法调整队列和 channel 的对应关系。

### 2.2 队列与数据流

- **g_TypeQueueUart0Read**：对应 **UART_LOG** 的接收环形队列。
- **g_TypeQueueUart1Read**：对应 **UART_BUS** 的接收环形队列。

UART 接收由 DMA + 空闲中断（或等效机制）把数据写入对应队列，任务侧只从队列**读**，实现**生产者（中断/DMA）— 消费者（任务）**解耦。

---

## 3. 任务角色概览

| 任务                 | 角色       | 解析方式     | 数据来源       | 典型用途 |
| :------------------- | :--------- | :----------- | :------------- | :------- |
| **TaskMessageSlave**  | 从机/透传 | **逐字节**   | 上位机/总线入队数据 | 响应上位机、转发到 BUS 或本机应答 |
| **TaskMessageUpdate** | 主动请求  | **整包**     | 本任务发请求后读回 | 定时轮询从机数据（如 BMS、INV、MPPT） |
| **TaskMessageControl**| 主动请求  | **整包**     | 本任务发请求后读回 | 控制类写/读（如 AC 输出、充电功率、BMS 指令） |

---

## 4. TaskMessageSlave（从机 / 透传）— 逐字节解析

### 4.1 职责

- 处理**上位机（或总线主机）**发来的 Modbus 帧。
- 数据来源：UART 接收后写入的**环形队列**（本工程中为 `g_TypeQueueUart1Read`，即 UART_BUS 对应队列）。
- 不预先假设帧长，采用**状态机逐字节**解析，适合“谁先发、发多长都不知道”的被动接收场景。

### 4.2 流程简述

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     TaskMessageSlave 主循环                               │
└─────────────────────────────────────────────────────────────────────────┘
         │
         ▼
   xTaskNotifyWait(0, 0xFFFFFFFF, &uiNotifiedValue, 20ms)  // 可被其他任务唤醒或超时
         │
         ▼
   while (队列有数据)
         │
         ├─ iLength = iQueueGetLengthOfOccupy(&g_TypeQueueUart1Read)
         ├─ 长度限制到本地缓冲区大小（如 256）
         ├─ enumQueuePopDatas(..., st_ucMessageAnalysisBuff, iLength)
         └─ cModbusUnpack(UART_LOG, st_ucMessageAnalysisBuff, iLength)
```

- **cModbusUnpack** 内部对 `st_ucMessageAnalysisBuff` 做**逐字节**送入 `enumModbusUnpack()`，直到解析出一帧完整 Modbus（地址 + 功能码 + 数据 + CRC），返回 `MODBUS_UNPACK_SUCCEED`。

### 4.3 DriverModbus 内对从机数据的处理（cModbusUnpack）

- **空闲超时**：若距上次调用 `cModbusUnpack`（即上次收到数据）超过约 500ms，将解析状态机复位为 `MODBUS_UNPACK_ADDRESS`，避免半帧粘连。
- 每解析出一帧：
  - **从站地址 == MODBUS_ADDRESS_PD（本机，0x10）**  
    → 调用 **cModbusMessageAnalysis(uiChannel, &st_typeModBusRtuHandle)**：  
    按功能码 0x03/0x06/0x10 等访问本机寄存器或执行本机动作，并**通过 uiChannel（如 UART_LOG）回复上位机**。  
    此路径**不使用 UART_BUS**，因此**不需要获取 g_xRS485BusSemaphore**，只在 `cModbusSendDatas` 内获取 `uiChannel` 对应的互斥量（如 `g_xUartLogSemaphore`）。
  - **从站地址 != 本机**  
    → **透传**：调用 **cModbusSeriaNet(uiChannel, &st_typeModBusRtuHandle)**：  
    先拿 **g_xRS485BusSemaphore**，清 BUS 接收、把该帧发到 **UART_BUS**，等从机应答（长度由功能码推算），再把收到的应答**通过 uiChannel 发回上位机**，最后释放互斥量。  
    OTA 进行中可不做透传，避免占用总线。

因此：**从机路径 = 逐字节解包 + 本机应答 or 透传**，回复使用的物理通道由调用 `cModbusUnpack` 时传入的 `uiChannel` 决定。

---

## 5. TaskMessageUpdate（主动请求）— 整包解析

### 5.1 职责

- **主控主动**向总线上的从机（如 BMS、逆变器、MPPT、IP2366 等）发起 Modbus 读请求。
- 请求帧长度、预期应答长度**已知**，因此采用**整包接收 + 整包解析**，无需逐字节状态机。

### 5.2 流程简述

- 任务周期由**软定时器**（如 2s 轮询 BMS/INV）或**任务通知**触发。
- 每次触发后，根据业务调用 DriverModbus 的**主动请求接口**，例如：
  - **cModbusDatasGet**：读多个保持寄存器（功能码 0x03）。
- 这些接口内部会：
  1. **xSemaphoreTakeRecursive(g_xRS485BusSemaphore, portMAX_DELAY)** 获取 BUS 互斥量。
  2. **cModbusReceiveClear(UART_BUS)** 清空该通道接收队列/缓存。
  3. 组 Modbus 请求帧并 **cModbusSendDatas(UART_BUS, ...)** 发送。
  4. 按**预期应答长度**循环 **cModbusReceiveDatas** 直到收满或超时。
  5. 若收满，再 **iModbusReceiveAllDatas** 把可能多收的尾字节读掉。
  6. **enumModbusReplyUnpackDatas** 对整包做解析与 CRC 校验。
  7. **xSemaphoreGiveRecursive(g_xRS485BusSemaphore)** 释放互斥量。

因此：**主动请求 = 已知长度 + 整包收 + 整包解**，不经过 TaskMessageSlave 的逐字节解析。

---

## 6. TaskMessageControl（控制）— 整包解析

### 6.1 职责

- **主控主动**向从机下发**控制类**指令（写单寄存器 0x06、写多寄存器 0x10 等），或为配合控制所做的读。
- 与 TaskMessageUpdate 一样：请求与应答长度已知，使用 **cModbusDatasSet** / **cModbusRegisterSet** 等接口，在 DriverModbus 内**整包收发、整包解析**。

### 6.2 流程简述

- 任务由 **ulTaskNotifyTake(pdTRUE, 100ms)** 等**任务通知**或周期逻辑触发。
- 在非 OTA 等条件下，按业务调用：
  - 逆变器：AC 输出、充电电压、风扇、PBoost 等；
  - BMS：不允许关机、屏显、充电状态等；
  - MPPT：充电功率等。
- 每次调用都会在 DriverModbus 内**拿 BUS 互斥量 → 清接收 → 发请求 → 按预期长度收应答 → 整包解析 → 释放互斥量**。

与 TaskMessageUpdate 的差异仅在**业务内容**（轮询数据 vs 控制指令），**通讯机制一致**：都是主动请求 + 整包解析。

---

## 7. DriverModbus 与互斥量

### 7.1 信号量

| 信号量                   | 作用 |
| :----------------------- | :--- |
| **g_xRS485BusSemaphore** | 保护 **UART_BUS**（RS485）：透传（cModbusSeriaNet）、主动读（cModbusDatasGet）、主动写（cModbusDatasSet）等所有使用 BUS 的路径必须先 Take，用完后 Give。 |
| **g_xUartLogSemaphore**  | 保护 **UART_LOG**：如通过 LOG 口发送回复或日志时使用，避免多任务同时发。 |

两者均为**递归互斥量**（Recursive Mutex），同一任务内可重复获取而不死锁。

### 7.2 发送统一入口：cModbusSendDatas

- 根据 `uiChannel` 选择对应互斥量（UART_LOG / UART_BUS）。
- **Take 互斥量 → 可选前导延时 iFrontTime → 调用 vUartDMASendDatas / cRS485xSendDatas 发送 → Give 互斥量**。  
所有“通过某通道发 Modbus 数据”的代码都应经此接口，保证通道互斥。

### 7.3 接收与清空

- **cModbusReceiveDatas**：从对应通道的队列中按指定长度取数（底层即队列 Pop）。
- **iModbusReceiveAllDatas**：把当前队列中剩余数据一次取完（用于收满一帧后清掉可能的多余字节）。
- **cModbusReceiveClear**：将对应通道接收队列置空（enumQueueSetState(..., queueEmpty)）。  
主动请求前必须 Clear，避免混入上一帧或透传残留。

---

## 8. 完整数据流小结

### 8.1 上位机 → 主控（从机/透传）

```
上位机/主机
    │ Modbus 帧
    ▼
UART（LOG 或 BUS，依硬件接法）
    │ DMA + 空闲中断
    ▼
g_TypeQueueUart1Read（本工程为 BUS 队列）
    │
    ▼
TaskMessageSlave
    │ 按当前长度 Pop 到 st_ucMessageAnalysisBuff
    ▼
cModbusUnpack(uiChannel, buff, len)
    │ 逐字节 enumModbusUnpack() 直至一帧完整
    ▼
┌───────────────────────────────────────┐
│ 从站地址 == MODBUS_ADDRESS_PD ?       │
├─────────────┬─────────────────────────┤
│ 是          │ 否                      │
│ cModbusMessageAnalysis()              │ cModbusSeriaNet()
│ 读/写本机寄存器，组应答                │ 拿 g_xRS485BusSemaphore
│ cModbusSendDatas(uiChannel, 回复)     │ 清 BUS 接收 → 发 BUS → 等从机应答
│             │                         │ 收完后 cModbusSendDatas(uiChannel, 应答)
│             │                         │ Give 互斥量
└─────────────┴─────────────────────────┘
    │
    ▼
回复经 uiChannel 发回上位机
```

### 8.2 主控主动请求（Update / Control）

```
TaskMessageUpdate / TaskMessageControl
    │ 软定时器或任务通知触发
    ▼
cModbusDatasGet() / cModbusDatasSet() / cModbusRegisterSet() 等
    │
    ├─ xSemaphoreTakeRecursive(g_xRS485BusSemaphore)
    ├─ cModbusReceiveClear(UART_BUS)
    ├─ cModbusPackRTU_03 / _10 等组请求
    ├─ cModbusSendDatas(UART_BUS, 请求)
    ├─ 按预期长度 cModbusReceiveDatas + 超时循环
    ├─ iModbusReceiveAllDatas 收尾
    ├─ enumModbusReplyUnpackDatas 整包解析
    └─ xSemaphoreGiveRecursive(g_xRS485BusSemaphore)
    │
    ▼
结果写回业务结构体（BMS/INV/MPPT 等），或仅检查错误码
```

---

## 9. 设计要点归纳

| 项目         | 从机（TaskMessageSlave）     | 主动请求（Update/Control）      |
| :----------- | :--------------------------- | :------------------------------ |
| **解析方式** | 逐字节状态机（enumModbusUnpack） | 整包解析（enumModbusReplyUnpackDatas） |
| **原因**     | 帧长未知，被动接收           | 请求与应答长度已知              |
| **数据来源** | 接收队列（当前工程 UART_BUS 队列） | 本任务发请求后从同一 BUS 读回   |
| **总线占用** | 本机应答**不需要** BUS 互斥量；透传时在 cModbusSeriaNet 内拿/放 g_xRS485BusSemaphore | 在 cModbusDatasGet/Set 内拿/放 g_xRS485BusSemaphore |
| **回复方向** | 本机应答或透传应答经 uiChannel 回上位机 | 无“回上位机”，结果仅用于本机业务 |

整体上：**DriverModbus** 统一负责组包、解包、收发与互斥；**TaskMessageSlave** 只消费队列并调用 `cModbusUnpack`；**TaskMessageUpdate / TaskMessageControl** 只按业务调用 `cModbusDatasGet/Set` 等，不直接参与逐字节解析。这样主控与上位机的通讯流程清晰，且与“透传 / 主动请求”两种模式一致对应到同一份设计文档。
