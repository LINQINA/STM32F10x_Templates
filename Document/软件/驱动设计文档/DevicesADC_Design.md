# STM32F10x ADC 驱动设计文档 (DevicesADC)

| 属性 | 内容 |
| :--- | :--- |
| **模块名称** | DevicesADC (ADC驱动模块) |
| **源文件** | `DevicesADC.c` / `DevicesADC.h` |
| **硬件依赖** | STM32F103 (ADC1, ADC2, DMA1) |
| **版本** | v2.0 (双 ADC 独立架构版) |
| **最后更新** | 2026-01-22 |

---

## 1. 设计目标 (Design Goals)
本驱动旨在解决嵌入式系统中常见的“采样矛盾”：
1.  **高频实时性**：需要对某些信号（如电流、波形）进行高频连续采集，不能占用 CPU。
2.  **低频灵活性**：需要对某些信号（如电池电压、温度）进行低频按需采集，不希望浪费 DMA 带宽。
3.  **互不干扰**：高频采集和低频采集必须物理隔离，避免配置冲突导致数据错乱。

---

## 2. 硬件架构 (Hardware Architecture)

为了实现上述目标，本驱动采用了 **双 ADC 独立架构**，完全复刻了工业级项目的稳健设计。

| 资源 | 用途 | 采集模式 | 对应通道 | 采样策略 |
| :--- | :--- | :--- | :--- | :--- |
| **ADC1** | **快速通道** | **DMA + 规则组** | PA1 (Channel 1) | **后台连续运行**。DMA 自动搬运数据到内存，CPU 随时读取最新值。 |
| **ADC2** | **慢速通道** | **轮询 + 规则组** | PA5 (Channel 5) | **前台按需运行**。调用函数时才启动转换，采完即停。 |

### 2.1 为什么使用双 ADC？
STM32 的每个 ADC 只有一套“规则组寄存器 (SQR)”。
*   如果 ADC1 既跑 DMA 又跑轮询，轮询时修改 SQR 会打断 DMA，导致数据错乱。
*   使用 **ADC1 跑 DMA**，**ADC2 跑轮询**，相当于用了两台独立的“采集机器”，物理上彻底隔离，互不干扰。

---

## 3. 软件实现细节 (Implementation Details)

### 3.1 快速采集 (ADC1 + DMA)
*   **初始化**：在 `vADCInit` 中配置 ADC1 为连续扫描模式，并绑定 DMA1_Channel1。
*   **运行机制**：DMA 开启 `Circular` (循环) 模式，自动将 ADC1 的转换结果搬运到全局数组 `st_usADC1DmaDatas`。
*   **数据获取**：调用 `vADCxScanHigh()`，直接从内存数组中读取数据，耗时极短（微秒级）。

### 3.2 慢速采集 (ADC2 + Polling)
*   **初始化**：在 `vADCInit` 中配置 ADC2，但不启动转换。
*   **运行机制**：调用 `fADCxChannelValueGet` 时：
    1.  配置 ADC2 的规则组为目标通道（如 PA5）。
    2.  启动 ADC2 -> 等待转换完成 -> 读取数据。
    3.  **滤波算法**：采用“去极值平均滤波”（采集 N 次，去掉最大最小值后求平均），以消除电源纹波和突发噪声。
*   **注意**：此过程是**阻塞**的，耗时取决于采样次数 `uiCnt`。

### 3.3 关键函数说明

| 函数名 | 所属 ADC | 说明 |
| :--- | :--- | :--- |
| `vADCInit` | ADC1 & 2 | 初始化 GPIO、时钟、ADC1(DMA)、ADC2(轮询)。**包含自动校准**。 |
| `vADCxScanHigh` | ADC1 | **非阻塞**。从 DMA 缓存更新快速通道数据。建议在定时器中断或主循环中调用。 |
| `vADCxScanLow` | ADC2 | **阻塞**。调用 `fADCxChannelValueGet` 采集慢速通道数据。建议在低频任务中调用。 |
| `fADCxChannelValueGet` | ADC2 | 核心轮询函数。包含通道配置、丢弃首个数据（防抖）、多次采样滤波。 |

---

## 4. 常见问题与知识点 (Q&A)

### Q1: 为什么慢速采集要丢弃第一次数据？
```c
/* 切换通道后，丢弃第一次转换的数据 */
HAL_ADC_Start(adc_periph);
HAL_ADC_PollForConversion(adc_periph, 10);
HAL_ADC_GetValue(adc_periph); // 读出来扔掉
```
**A**: ADC 内部有采样电容。当从一个电压（如 3.3V）切换到另一个电压（如 0.1V）时，电容上可能有残留电荷。丢弃第一次数据可以消除这种“通道间串扰”，提高准确性。

### Q2: 为什么不把所有通道都放到 ADC1 的 DMA 里？
**A**:
1.  **采样率匹配**：快速通道可能需要 10kHz 采样率，慢速通道只需要 1Hz。如果混在一起，慢速通道会占用宝贵的 DMA 带宽和内存。
2.  **灵活性**：慢速通道通常是“按需读取”的（比如按键按下才读），没必要让 DMA 24小时不停地采它。

### Q3: 规则组 (Regular) vs 注入组 (Injected)？
*   **规则组**：只有 1 个数据寄存器，适合配合 DMA 做大批量数据搬运。
*   **注入组**：有 4 个独立数据寄存器，适合做“插队”采样。
*   **本驱动策略**：因为我们有 ADC2，所以直接让 ADC2 跑规则组轮询。如果只有 ADC1，则必须用注入组来做轮询，否则会打断 DMA。

### Q4: 为什么初始化时要手动校准 (`HAL_ADCEx_Calibration_Start`)？
**A**: ADC 的精度会受温度、电压影响。上电时进行一次自校准，可以消除内部电路的固定偏差（Offset），大幅提高测量精度。

---

## 5. 移植与扩展 (Porting Guide)

### 如果要增加新的快速通道 (DMA)
1.  在 `DevicesADC.h` 中增加通道枚举。
2.  修改 `ADC1_SAMPLING_CHANNEL` 宏。
3.  在 `vADC1DMAInit` 中修改 `adc_Channel_Config`，增加新的 `HAL_ADC_ConfigChannel` 配置。
4.  **注意**：增加通道会略微降低每个通道的有效采样率。

### 如果要增加新的慢速通道 (轮询)
1.  初始化对应的 GPIO 为模拟输入。
2.  在 `vADCxScanLow` 中直接调用 `fADCxChannelValueGet`，传入新的通道号即可。
3.  **完全不需要**修改 ADC 初始化代码。

---

## 6. 代码质量自检 (Self-Check)
*   [x] **DMA 句柄安全**：`st_typeDMAADC_handle` 已声明为 `static`，防止栈内存释放导致野指针。
*   [x] **参数保护**：滤波函数已添加 `uiCnt < 3` 的边界检查。
*   [x] **独立性**：ADC1 和 ADC2 句柄分离，配置互不覆盖。

---

**文档结束**
