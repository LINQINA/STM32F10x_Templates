# STM32 BSP 驱动模块学习笔记

**日期**: 2026-01-23
**涉及模块**: `DevicesLed`, `DevicesBeep`, `DevicesKey`
**基于架构**: STM32F10x + FreeRTOS

---

## 一、 核心架构设计思想

这三个模块共同遵循了一套高效、省资源的嵌入式软件设计模式，特别适合资源受限（RAM/Flash 有限）的 MCU。

### 1. FreeRTOS 软件定时器 (Software Timer) 的应用
所有模块均运行在 FreeRTOS 的软件定时器回调中，而非独立的 Task 或硬件中断。

*   **优势**:
    *   **极大节省 RAM**: 避免了为每个功能模块分配独立的任务栈（Task Stack，通常需 >512 Bytes）。软件定时器共用系统 `Tmr Svc` 任务的栈。
    *   **非阻塞 (Non-blocking)**: 回调函数执行极快，无 `delay`，不占用 CPU 资源。
    *   **安全性**: 避免了在硬件中断中进行耗时运算（如呼吸灯浮点运算）导致的系统卡顿。
*   **时序保证**:
    *   使用 `vTaskDelayUntil` (绝对延时) 思想，保证了状态机每 20ms (或其他周期) 准时触发一次。
    *   **优先级**: 只要系统定时器任务 (`Tmr Svc`) 优先级设置得当，且高优先级任务不霸占 CPU，定时器回调就能准时运行。

### 2. 状态机 (State Machine) 模式
抛弃了线性的 `while` 循环和 `delay` 延时，采用状态机模式。
*   **输入**: 当前时间 tick、硬件 IO 状态。
*   **处理**: 根据当前状态 (`state`) 判断下一步动作。
*   **输出**: 改变 IO 电平或更新状态变量。

---

## 二、 模块详解

### 1. LED 驱动模块 (`DevicesLed`)

**功能**: 实现 LED 的开关、闪烁、呼吸灯、SOS 信号。

*   **硬件抽象**: 支持 PWM 驱动（红灯）和普通 IO 驱动（绿灯），通过 `LedType` 结构体封装差异。
*   **核心算法**:
    *   **呼吸灯 (Gamma 校正)**: 使用抛物线公式 $y = x^2$ 模拟人眼对亮度的非线性感知。
        ```c
        // 亮度计算，110 为最大刻度
        Duty = (Grade * Grade) * (1.0f / (110.0f * 110.0f));
        ```
    *   **往复运动**: 变量 `st_sGrade` 在 `-15` 到 `110` 之间摆动。
        *   **死区设计 (-15 ~ 0)**: 让灯在熄灭状态停留片刻，增强呼吸的真实感。
    *   **SOS 循环**: 利用取模运算实现周期性播放。
        ```c
        // 自动归零，无需 if 判断
        Cnt %= (FAST*3 + SLOW*3 + FAST*3 + DELAY);
        ```

### 2. 蜂鸣器模块 (`DevicesBeep`)

**功能**: 无源蜂鸣器驱动。

*   **物理特性悖论**:
    *   **无源蜂鸣器**: 靠 PWM 波驱动振膜震动发声。
    *   **100% 占空比**: 等于直流高电平，振膜不动，**静音**。
    *   **50% 占空比**: 振膜震动幅度最大，**声音最响**。
*   **频率意义**: `2048Hz` 决定音调，占空比决定响度。

### 3. 按键驱动模块 (`DevicesKey`) 

**功能**: 支持短按、长按、持续按、组合键，全非阻塞消抖。

*   **高效过滤**:
    *   入口处判断 `if (New==0 && Old==0)`。当按键“都空闲”时直接跳过所有逻辑，极致省流。
*   **位运算集合逻辑 (核心)**:
    *   利用位运算判断按键集合的包含关系，支持任意组合键。
    *   **新增 (Add)**: `(New & Old) == Old` (旧的是新的子集)。
    *   **减少 (Cut)**: `(New | Old) == Old` (新的是旧的子集)。

    **图解韦恩图 (Venn Diagram) —— 两个圆的关系**:
    假设 **大圆** 代表包含更多按键的集合，**小圆** 代表包含较少按键的集合。

![image-20260123114357327](C:\Users\10673\AppData\Roaming\Typora\typora-user-images\image-20260123114357327.png)





*   **时间阈值消抖**:
    * 消抖的核心在于：**“不见兔子不撒鹰”**。只有经过时间验证的信号，才会被打上有效标签 (`keyShort`)。
    
      **场景模拟：一次带有抖动的按键过程**
    
      1.  **T0 (按下瞬间)**: 
          *   检测到 `keyAdd`。
          *   动作：记录 `TimePress = T0`，状态设为 `keyAdd`。
          *   *注意*：此时 **没有** `keyShort` 标志。
    
      2.  **T0 + 10ms (抖动)**: 
          *   因为机械抖动，电平短暂变回 0。
          *   检测到 `keyCut` (松开)。
          *   动作：触发松开逻辑。
          *   **关键判定**: 上层应用 (`taskKey`) 检查状态 `if (State & keyShort)`。
          *   **结果**: 因为此时还没有 `keyShort` 标志，**这次松开被视为无效噪音，直接忽略**。
    
      3.  **T0 + 20ms (重新按下)**: 
          *   抖动结束，电平稳定为 1。
          *   检测到 `keyAdd`。
          *   动作：**重置** `TimePress = T0+20ms`，重新开始计时。
    
      4.  **T0 + 70ms (稳定保持)**: 
          *   检测到 `keyEqual` (按着没动)。
          *   计算时长：`CurrentTime - TimePress = 50ms`。
          *   动作：满足 `KEY_SHORT_TIME` 阈值，**加上 `keyShort` 标志位**。
    
      5.  **T0 + 100ms (真正松手)**: 
          *   检测到 `keyCut`。
          *   动作：触发松开逻辑。
          *   **关键判定**: 上层应用检查 `if (State & keyShort)`。
          *   **结果**: 条件成立！执行短按功能。
*   **状态分层**:
    *   **低8位**: 动作状态 (Add/Cut/Equal)。
    *   **高8位**: 时间属性 (Short/Long/Continuous)。
    *   **状态清除**: 使用 `state &= ~0x00FF` 清除旧动作，保留时间属性。

---

## 三、 C 语言关键技巧

### 1. `volatile` 关键字
*   **作用**: 告诉编译器该变量是“易变”的，强制每次从 RAM 读取，禁止寄存器缓存优化。
*   **场景**:
    *   中断服务函数 (ISR) 修改的变量。
    *   硬件寄存器映射。
    *   多任务共享变量。
*   **辨析**: 局部静态变量 (`static`) 如果只在单线程内部使用，通常不需要加 `volatile`，但在调试时加上有助于观察变量值。

### 2. 位操作 (Bitwise Operations)
*   **置位**: `val |= FLAG;`
*   **清零**: `val &= ~FLAG;`
*   **判断**: `if (val & FLAG)`
*   **集合判断**: 见按键驱动章节。

### 3. 归一化处理
*   无论硬件是上拉还是下拉，底层函数 `uiKeyValueGet` 统一将“按下”转换为逻辑 `1`，上层逻辑无需关心硬件电路差异。

---

## 四、 总结

这套 BSP 驱动代码展示了**高内聚、低耦合**的设计思想。通过将硬件操作封装在底层，利用状态机处理复杂时序，并结合 RTOS 的特性进行资源优化，是嵌入式进阶学习的优秀范本。
